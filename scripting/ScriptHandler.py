'''
Created on Aug 6, 2015

@author: jmizrahi
'''

from PyQt4 import QtCore
import os
import logging
import traceback
import numpy
from datetime import datetime
from modules import magnitude
from Script import ScriptException
from trace.PlottedTrace import PlottedTrace
from trace.TraceCollection import TraceCollection
from trace import pens
from pyqtgraph.graphicsItems.ViewBox import ViewBox
import functools
import pytz
from persist.MeasurementLog import  Measurement, Parameter, Result

class ScriptHandler:
    """The ScriptHandler is what handles all the interfacing between the Script and the GUI. The Script
    emits signals, which are picked up by the ScriptHandler, which executes the necessary changes on the
    GUI."""
    def __init__(self, script, experimentUi):
        self.experimentUi = experimentUi
        self.scanExperiment = experimentUi.tabDict['Scan']
        self.globalVariablesUi = experimentUi.globalVariablesUi
        self.scanControlWidget = self.scanExperiment.scanControlWidget
        self.evaluationControlWidget = self.scanExperiment.evaluationControlWidget
        self.analysisControlWidget = self.scanExperiment.analysisControlWidget
        self.fitWidget = self.scanExperiment.fitWidget
        self.pulser = self.experimentUi.pulser
        self.currentLines = []
        self.script = script
        self.scriptTraces = dict() #Place to put traces generated by the script
        self.traceAlreadyCreated = dict() #Place to keep track of whether or not a given trace has been added to the traceUi
        
        #Experiment information signals
        self.scanExperiment.progressUi.stateChanged.connect(self.onScanStateChanged)
        self.analysisControlWidget.analysisResultSignal.connect(self.onAnalysisResult)
        self.scanExperiment.evaluatedDataSignal.connect(self.onData)
        self.scanExperiment.allDataSignal.connect(self.onAllData)
        
        #status signals
        self.script.locationSignal.connect( self.onLocation )
        self.script.exceptionSignal.connect( self.onException )
        self.script.consoleSignal.connect( self.onConsoleSignal )

        #action signals
        self.script.setGlobalSignal.connect(self.onSetGlobal)
        self.script.addGlobalSignal.connect(self.onAddGlobal)
        self.script.pauseScriptSignal.connect(self.onPauseScriptFromScript)
        self.script.stopScriptSignal.connect(self.onStopScriptFromScript)
        self.script.startScanSignal.connect(self.onStartScan)
        self.script.setScanSignal.connect(self.onSetScan)
        self.script.setEvaluationSignal.connect(self.onSetEvaluation)
        self.script.setAnalysisSignal.connect(self.onSetAnalysis)
        self.script.plotPointSignal.connect(self.onPlotPoint)
        self.script.plotListSignal.connect(self.onPlotList)
        self.script.addPlotSignal.connect(self.onAddPlot)
        self.script.pauseScanSignal.connect(self.onPauseScan)
        self.script.stopScanSignal.connect(self.onStopScan)
        self.script.abortScanSignal.connect(self.onAbortScan)
        self.script.createTraceSignal.connect(self.onCreateTrace)
        self.script.closeTraceSignal.connect(self.onCloseTrace)
        self.script.fitSignal.connect(self.onFit)

        #finished signal
        self.script.finished.connect(self.onFinished)

    def scriptCommand(func):#@NoSelf
        """Decorator for script commands. 
        
        Catches exceptions, sets the script exception variables, and wakes the script after the
        specified action has been completed.
        """
        def baseScriptCommand(self, *args, **kwds):
            logger = logging.getLogger(__name__)
            try:
                error, message = func(self, *args, **kwds)
                if error and message:
                    logger.error(message)
                    self.writeToConsole(message, error=True)
                    raise ScriptException(message)
                elif error and (not message):
                    raise ScriptException('')
                elif (not error) and message:
                    logger.debug(message)
                    self.writeToConsole(message)
            except Exception as e:
                with QtCore.QMutexLocker(self.script.mutex):
                    self.script.exception = e
                    logger.error(traceback.print_exc())
            finally:
                self.script.guiWait.wakeAll()
        baseScriptCommand.func_name = func.func_name
        baseScriptCommand.func_doc = func.func_doc
        return baseScriptCommand
    
    @QtCore.pyqtSlot(str, float, str)
    @scriptCommand
    def onAddGlobal(self, name, value, unit):
        """Add a global 'name' and set it to 'value, unit'"""
        name = str(name) #signal is passed as a QString
        value = float(value)
        unit = str(unit)
        magValue = magnitude.mg(value, unit)
        doesNotExist = name not in self.globalVariablesUi.keys()
        if doesNotExist:
            self.globalVariablesUi.model.addVariable(name)
            message = "Global variable {0} created\n".format(name)
        else:
            message = "Global variable {0} already exists\n".format(name)
        self.globalVariablesUi.model.update([('Global', name, magValue)])
        message +=  "Global variable {0} set to {1} {2}".format(name, value, unit)
        error = False
        return (error, message)

    @QtCore.pyqtSlot(str, float, str)
    @scriptCommand
    def onSetGlobal(self, name, value, unit):
        """Set global 'name' to 'value, unit'"""
        name = str(name) #signal is passed as a QString
        value = float(value)
        unit = str(unit)
        magValue = magnitude.mg(value, unit)
        doesNotExist = name not in self.globalVariablesUi.keys()
        if doesNotExist:
            message = "Global variable {0} does not exist.".format(name)
            error = True
        else:
            self.globalVariablesUi.model.update([('Global', name, magValue)])
            message = "Global variable {0} set to {1} {2}".format(name, value, unit)
            error = False
        return (error, message)
    
    @QtCore.pyqtSlot()
    @scriptCommand
    def onStartScan(self):
        """Start the scan"""
        logger = logging.getLogger(__name__)
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.scanIsRunning = True
            self.script.analysisReady = False
            self.script.dataReady = False
            self.script.allDataReady = False
        self.experimentUi.actionStart.trigger()
        scan = self.scanControlWidget.settingsName
        evaluation = self.evaluationControlWidget.settingsName
        analysis = self.analysisControlWidget.currentAnalysisName
        message = "Scan started at {0} with scan = {1}, evaluation = {2}, analysis = {3}".format(str(datetime.now()), scan, evaluation, analysis)
        logger.info(message)
        self.writeToConsole(message, color='green')
        return (False, None)

    @QtCore.pyqtSlot()
    @scriptCommand
    def onPauseScan(self):
        self.experimentUi.actionPause.trigger()
        error = False
        message = "Scan paused"
        return (error, message)
        
    @QtCore.pyqtSlot()
    @scriptCommand
    def onStopScan(self):
        self.experimentUi.actionStop.trigger()
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.scanIsRunning = False
        error = False
        message = "Scan stopped"
        return (error, message)
        
    @QtCore.pyqtSlot()
    @scriptCommand
    def onAbortScan(self):
        self.experimentUi.actionAbort.trigger()
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.scanIsRunning = False
        error = False
        message = "Scan aborted"
        return (error, message)

    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onSetScan(self, name):
        name = str(name)
        doesNotExist = (self.scanControlWidget.comboBox.findText(name)==-1)
        if doesNotExist:
            message = "Scan {0} does not exist.".format(name)
            error = True
        else:
            self.scanControlWidget.loadSetting(name)
            message = "Scan set to {0}".format(name)
            error = False
        return (error, message)
    
    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onSetEvaluation(self, name):
        name = str(name)
        doesNotExist = (self.evaluationControlWidget.comboBox.findText(name)==-1)
        if doesNotExist:
            message = "Evaluation {0} does not exist.".format(name)
            error = True
        else:
            self.evaluationControlWidget.loadSetting(name)
            message = "Evaluation set to {0}".format(name)
            error = False
        return (error, message)
    
    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onSetAnalysis(self, name):
        name = str(name)
        doesNotExist = (name not in self.analysisControlWidget.analysisDefinitionDict)
        if doesNotExist:
            message = "Analysis {0} does not exist.".format(name)
            error = True
        else:
            self.analysisControlWidget.onLoadAnalysisConfiguration(name)
            message = "Analysis set to {0}".format(name)
            error = False
        return (error, message)
    
    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onAddPlot(self, name):
        if name not in self.scanExperiment.plotDict.keys():
            self.scanExperiment.addPlot(str(name))
            message = 'Plot {0} added'.format(name)
        else:
            message = 'Plot {0} already exists'.format(name)
        error = False
        return (error, message)
    
    @QtCore.pyqtSlot(list)
    @scriptCommand
    def onCreateTrace(self, traceCreationData):
        traceCreationData = map(str, traceCreationData)
        [traceName, plotName, xUnit, xLabel, comment] = traceCreationData
        if plotName not in self.scanExperiment.plotDict:
            message = "plot {0} does not exist".format(plotName)
            error = True
        else:
            traceCollection = TraceCollection()
            yColumnName = 'y0'
            traceCollection.addColumn( yColumnName )
            plottedTrace = PlottedTrace(traceCollection, self.scanExperiment.plotDict[plotName]["view"], pens.penList, xColumn = 'x',
                                        yColumn=yColumnName, name=traceName, xAxisUnit = xUnit, xAxisLabel = xLabel, windowName=plotName)
            self.scanExperiment.plotDict[plotName]["view"].enableAutoRange(axis=ViewBox.XAxis)
            plottedTrace.traceCollection.name = self.script.shortname
            commentIntro = "Created by script {0}".format(self.script.shortname)
            plottedTrace.traceCollection.comment = commentIntro + " -- " + comment if comment else commentIntro
            plottedTrace.traceCollection.autoSave = True
            plottedTrace.traceCollection.filenamePattern = traceName
            self.scriptTraces[traceName] = plottedTrace
            self.traceAlreadyCreated[traceName] = False #Keep track of whether the trace has already been added
            error = False
            message = "Added trace {0}\n plot: {1}\n xUnit: {2}\n xLabel: {3}\n comment: {4}".format(traceName, plotName, xUnit, xLabel, comment)
        return (error, message)

    @QtCore.pyqtSlot(str)
    @scriptCommand
    def onCloseTrace(self, traceName):
        traceName = str(traceName)
        if traceName not in self.scriptTraces:
            message = "Trace {0} does not exist".format(traceName)
            error = True
        else:
            plottedTrace = self.scriptTraces.pop(traceName) #remove from the list of script traces
            plottedTrace.traceCollection.description["traceFinalized"] = datetime.now(pytz.utc)
            plottedTrace.traceCollection.save()
            self.registerMeasurement(plottedTrace)
            message = "Trace {0} closed".format(traceName)
            error = False
        return error, message

    @QtCore.pyqtSlot(str, str)
    @scriptCommand
    def onFit(self, fitName, traceName):
        fitName = str(fitName)
        traceName = str(traceName)
        fitAnalysisIndex = self.fitWidget.analysisNameComboBox.findText('fitAnalysisName')
        if fitAnalysisIndex < 0:
            message = "Fit '{0}' does not exist.".format(fitName)
            error = True
        else:
            self.fitWidget.analysisNameComboBox.setIndex(fitAnalysisIndex)
            message = "Fit set to '{0}'".format(fitName)
            error = False
        return (error, message)

    @QtCore.pyqtSlot(float, float, str)
    @scriptCommand
    def onPlotPoint(self, x, y, traceName):
        """Plot point (x,y) to traceName"""
        traceName = str(traceName)
        error, message = self.plotList([x], [y], traceName)
        return (error, message) 
        
    @QtCore.pyqtSlot(list, list, str)
    @scriptCommand
    def onPlotList(self, xList, yList, traceName):
        """Plot [x1, x2,...], [y1, y2,...] to traceName"""
        traceName = str(traceName)
        error, message = self.plotList(xList, yList, traceName)
        return (error, message)
        
    def plotList(self, xList, yList, traceName):
        """Plot [x1, x2,...], [y1, y2,...] to traceName"""
        try:
            plottedTrace = self.scriptTraces[traceName]
            created = self.traceAlreadyCreated[traceName]
        except KeyError:
            message = "Trace {0} does not exist".format(traceName)
            error = True
            return (error, message)
        if not (len(xList)==len(yList)):
            message = 'x and y lists are of unequal lengths'
            error = True
            return (error, message)
        else:
            if created:
                plottedTrace.x = numpy.append(plottedTrace.x, xList)
                plottedTrace.y = numpy.append(plottedTrace.y, yList)
                plottedTrace.replot()
            else:
                plottedTrace.x = numpy.array(xList)
                plottedTrace.y = numpy.array(yList)
                self.scanExperiment.traceui.addTrace(plottedTrace, pen=-1)
                if self.scanExperiment.traceui.expandNew:
                    self.scanExperiment.traceui.expand(plottedTrace)
                self.scanExperiment.traceui.resizeColumnsToContents()
                self.traceAlreadyCreated[traceName] = True
            message = '{0}, {1} plotted to trace: {2}'.format(xList, yList, traceName)
            error = False
        return (error, message)

    @QtCore.pyqtSlot()
    @scriptCommand
    def onPauseScriptFromScript(self):
        self.experimentUi.scriptingWindow.onPauseScript(True)
        message = None
        error = False
        return (error, message)

    @QtCore.pyqtSlot()
    @scriptCommand
    def onStopScriptFromScript(self):
        self.onStopScript()
        message = 'script stopped'
        error = False
        return (error, message)        
    
    def onStartScript(self):
        """Runs when start script button clicked. Starts the script and disables some aspects of the script GUI"""
        if not self.script.isRunning():
            with QtCore.QMutexLocker(self.script.mutex):
                self.script.paused = False
                self.script.stopped = False
                self.script.exception = None
                self.script.start()

    def onPauseScript(self, paused):
        """Runs when pause script button clicked. Sets paused variable and wakes up script if unpaused."""
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.paused = paused
            if not paused:
                self.script.pauseWait.wakeAll()
        
    def onStopScript(self):
        """Runs when stop script button is clicked. Sets stopped variable and wakes up all waitConditions.""" 
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.stopped = True
            self.script.paused = False
            self.script.waitOnScan = False
            self.script.repeat = False
            self.script.analysisReady = True
            self.script.dataReady = True
            self.script.allDataReady = True
            self.script.guiWait.wakeAll()
            self.script.pauseWait.wakeAll()
            self.script.scanWait.wakeAll()
            self.script.dataWait.wakeAll()
            self.script.analysisWait.wakeAll()
            
    def onPauseScriptAndScan(self):
        """Runs when pause script and scan button is clicked."""
        self.onPauseScript(True)
        self.experimentUi.actionPause.trigger()
        
    def onStopScriptAndScan(self):
        """Runs when stop script and scan button is clicked."""
        self.onStopScript()
        self.experimentUi.actionStop.trigger()

    def onRepeat(self, repeat):
        """Runs when repeat button is clicked. Set repeat variable."""
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.repeat = repeat

    def onSlow(self, slow):
        """Runs when slow button is clicked. Set slow variable."""
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.slow = slow
            
    @QtCore.pyqtSlot(str)
    def onScanStateChanged(self, state):
        """Runs when the scan state changes"""
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.scanStatus = state
            if state == 'idle':
                self.writeToConsole("scan finished at {0}".format(str(datetime.now())), False, 'green')
                self.script.scanIsRunning = False
                self.script.scanWait.wakeAll()
            else:
                self.script.scanIsRunning = True

    @QtCore.pyqtSlot(object)
    def onAnalysisResult(self, allResults):
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.analysisResults = allResults
            self.script.analysisReady = True
            self.script.analysisWait.wakeAll()

    @QtCore.pyqtSlot(dict)
    def onData(self, data):
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.data = data
            self.script.dataReady = True
            self.script.dataWait.wakeAll()

    @QtCore.pyqtSlot(dict)
    def onAllData(self, allData):
        with QtCore.QMutexLocker(self.script.mutex):
            self.script.allData = allData
            self.script.allDataReady = True
            self.script.allDataWait.wakeAll()

    @QtCore.pyqtSlot()
    def onFinished(self):
        for plottedTrace in self.scriptTraces.values():
            plottedTrace.traceCollection.description["traceFinalized"] = datetime.now(pytz.utc)
            plottedTrace.traceCollection.save()
            self.registerMeasurement(plottedTrace)

    @QtCore.pyqtSlot(str, bool, str)
    def onConsoleSignal(self, message, error, color):
        """Runs when script emits a console signal. Writes message to console."""
        self.writeToConsole(message, error=error, color=color)
    
    @QtCore.pyqtSlot(str, str)
    def onException(self, message, trace):
        """Runs when script emits exception signal. Highlights error."""
        logger = logging.getLogger(__name__)
        message = str(message)
        trace = str(trace)
        logger.error(trace)
        self.writeToConsole(trace, error=True)
        self.experimentUi.scriptingWindow.markError(self.currentLines, message)
    
    @QtCore.pyqtSlot(list)        
    def onLocation(self, locs):
        """Mark where the script currently is"""
        logger = logging.getLogger(__name__)
        self.currentLines = []
        if locs:
            self.currentLines = [loc[1] for loc in locs]
            for loc in locs:
                message = "Executing {0} in {1} at line {2}".format( loc[3], os.path.basename(loc[0]), loc[1] )
                logger.debug(message)
                self.writeToConsole(message, False)
        else: #This should never execute
            message = "onLocation called while not executing script"
            logger.warning(message)
            self.writeToConsole(message, True)
        self.experimentUi.scriptingWindow.markLocation(self.currentLines)
        
    def writeToConsole(self, message, error=False, color=''):
        """write a message to the console."""
        self.experimentUi.scriptingWindow.writeToConsole(message, error, color)

    def registerMeasurement(self, plottedTrace):
        """register a script created trace in the measurement log"""
        measurement = Measurement(scanType= 'Script', scanName=plottedTrace.traceCollection.filenamePattern,
                                  scanParameter='', scanTarget='',
                                  scanPP = '',
                                  evaluation='<Script {0}>'.format(self.script.shortname),
                                  startDate=plottedTrace.traceCollection.description['traceCreation'],
                                  duration=None,
                                  filename=plottedTrace.traceCollection.filename,
                                  comment=plottedTrace.traceCollection.comment,
                                  longComment=None,
                                  failedAnalysis=None)
        space = self.scanExperiment.measurementLog.container.getSpace('GlobalVariables')
        for name, value in self.experimentUi.globalVariablesUi.variables.iteritems():
            measurement.parameters.append( Parameter(name=name, value=value, space=space) )
        measurement.plottedTraceList = [plottedTrace]
        self.scanExperiment.measurementLog.container.addMeasurement(measurement)

